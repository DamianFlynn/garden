{
  "/posts/lang-terraform": {
    "title": "Terraform",
    "content": "\n\nThis is an introduction to Terraform\n\n![ðŸ’¡ resources/ðŸ“‚ files/lang-terraform.overview.png](lang-terraform/lang-terraform.overview.png)\n\n## Getting Started\n\nRead this to learn about [Strenghts of Terraform and Bicep](posts/lang-terraform-bicep)",
    "lastmodified": "2023-02-24T10:27:33.491756471Z",
    "tags": null
  },
  "/posts/lang-terraform-bicep": {
    "title": "Considering Terraform and Bicep",
    "content": "\n\nAs more organizations adopt cloud infrastructure, the demand for infrastructure as code (IAC) solutions has grown. Infrastructure as code allows developers to manage and automate infrastructure deployments using code, making it easier to track changes and maintain consistency.\n\nTerraform and Bicep are two popular IAC solutions that enable developers to manage and automate infrastructure deployments using code.\n\nWhile both tools share some similarities, Terraform is more widely adopted solution with many benefits,  In this post, we will highligh some of the benfits each expose, so you can start to figure out where you next learning should be focused\n\n## Bicep and ARM\n\nAzure Resource Manager (ARM) templates are a popular way to define and deploy infrastructure as code in Azure. However, writing ARM templates can be challenging, particularly for beginners. Bicep is a new language developed by Microsoft that makes writing Azure infrastructure code easier and more streamlined. In this blog post, we will explore the benefits of using Bicep over ARM.\n\n1. **Simpler Syntax**: Bicep's syntax is simpler and easier to read and write than ARM's. The code is written in JSON-like format and requires less boilerplate code. Additionally, Bicep has a smaller learning curve than ARM, making it easier for beginners to get started.\n    \n2. **Better Modularity**: Bicep's modular design allows developers to define reusable components and deploy them across multiple environments. This can help reduce code duplication and improve code maintainability. The modules in Bicep are simpler to define and use than the modules in ARM, which can make code reuse more accessible.\n    \n3. **Improved Type Safety**: Bicep provides type safety to help developers catch errors before deployment. The language's strong typing system ensures that variables are defined correctly and that the correct data types are used. This can help prevent errors in deployments and improve the overall quality of the code.\n    \n4. **Better Tooling**: Bicep has better tooling support than ARM. It is integrated with Visual Studio Code, which provides auto-completion and syntax highlighting for the language. Additionally, Bicep is integrated with Azure CLI, which makes it easier to manage and automate infrastructure deployments.\n    \n5. **Easier to Read and Maintain**: Bicep's simpler syntax and modular design make it easier to read and maintain compared to ARM. The code is less verbose and easier to understand, which can help reduce errors and improve code quality.\n    \n6. **Greater Consistency**: Bicep promotes consistency in infrastructure deployments. Developers can use templates across different environments, which can ensure that infrastructure is deployed consistently across all environments. This can help reduce errors and improve the overall quality of the infrastructure.\n    \nOf course, we can also ask the question, of what are the Benfits of ARM over Bicep. Azure Resource Manager (ARM) templates have been around for a while and are a widely adopted way to define and deploy infrastructure as code in Azure. While Bicep has many benefits, there are still some advantages to using ARM templates. \n\n1. **Widely Adopted**: ARM templates have been around for a while and are a widely adopted way to deploy infrastructure in Azure. Many organizations have already invested time and resources in building ARM templates, and they may find it easier to continue using them rather than switching to a new language.\n    \n2. **Better Compatibility**: ARM templates are compatible with more Azure services than Bicep. While Bicep is designed to work with Azure, ARM templates can be used with many other services and platforms, for example Azure Policy still requires ARM syntax.\n\n3. **Easier to Write for Experienced Developers**: Experienced developers *may* find it easier to write ARM templates than Bicep code. While Bicep is simpler and easier to learn for beginners, experienced developers may prefer the greater flexibility and complexity offered by ARM template\n\nIn conclusion, Bicep offers several benefits over ARM. Its simpler syntax, better modularity, improved type safety, better tooling, and easier-to-read code make it an attractive option for developers who are focused on Azure infrastructure. Additionally, its focus on consistency can help improve the overall quality of infrastructure deployments. While ARM templates remain a popular way to deploy Azure infrastructure, Bicep provides a more accessible and streamlined approach that can make infrastructure as code more accessible to developers of all skill levels.\n\n## Considerating Terraform\n\nBoth [Terraform](posts/lang-terraform)  and [bicep](bicep) use a declarative language, which means that it focuses on the desired end-state rather than the specific steps needed to achieve it. This makes it easier to manage and automate infrastructure changes.\n\nBoth options are very popular, and very powerful. At one point in time, Terraform was a poor option for working with Azure, and Bicep did not even exist (its just 2 years young). \n\nSelecting the Declarative Language and tooling is not black and white; so consider your requirements, and lets take a little time to conside their respective strengths.\n\n### Bicep Strengths\n\n1.  Simpler Syntax: Bicep has a simpler syntax than Terraform, making it easier for beginners to get started. The syntax is also more concise and readable, which can make code maintenance easier. The code is written in JSON-like format and requires less boilerplate code compared to Terraform's HashiCorp Configuration Language (HCL).\n    \n2.  Integrated Language: Bicep is built on top of the Azure Resource Manager (ARM) language and is fully integrated with Azure. This means that developers can use Bicep to write ARM templates that can be used with any Azure resource type. Additionally, Bicep has direct access to all Azure resources, including new features and services.\n    \n3.  Type Safety: Bicep provides type safety to help developers catch errors before deployment. The language's strong typing system ensures that variables are defined correctly and that the correct data types are used. This can help prevent errors in deployments and improve the overall quality of the code.\n    \n4.  Improved Modularity: Bicep's modular design allows developers to define reusable components and deploy them across multiple environments. This can help reduce code duplication and improve code maintainability. The modules in Bicep are simpler to define and use than the modules in Terraform, which can make code reuse more accessible.\n    \n5. Accessability: Bicep is included in the Azure Quickstart templates, which can make it easier to deploy infrastructure with a single click.\n\n### Terraform Strengths\n\n1.  Multi-cloud support: Terraform supports more cloud providers compared to Bicep. Terraform can be used to manage infrastructure across multiple cloud providers, including AWS, Azure, Google Cloud, and many others, while Bicep is currently only available for Azure.\n    \n2.  Greater ecosystem and community: Terraform has a larger and more active community compared to Bicep, making it easier to find resources, get help, and share knowledge.\n    \n3.  Modular design: Terraform's modular design allows for code reusability and easier management of large infrastructure deployments, while Bicep's module system is less robust and can be more challenging to maintain.\n    \n4.  Built-in state management: Terraform has built-in state management, which allows it to keep track of the current state of the infrastructure and make changes accordingly. Bicep relies on external state management - essentially the Azure Resource Manager.\n    \n5.  Richer documentation: Terraform has extensive documentation that covers every aspect of the tool, including configuration options, provider support, and best practices. Bicep's documentation is still developing and can be less comprehensive.\n    \n6.  More provider support: Terraform has a broader range of provider support compared to Bicep. This means that it can integrate with more services and resources from various cloud providers.\n    \n7.  Wider range of configuration options: Terraform provides more configuration options for its users, including custom providers, modules, and backend configurations, while Bicep's configuration options are more limited.\n    \n8.  More testing options: Terraform has more testing options compared to Bicep, such as testing infrastructure deployments with Terraform's built-in testing framework, Terratest.\n    \n9.  Greater maturity: Terraform has been around longer and has a more mature feature set, while Bicep is a relatively new tool and still in active development. Terraform has been battle-tested over the years and has a robust set of features.\n\n## Summary\n\nWhile Terraform is a popular IAC solution with many benefits, Bicep has some unique advantages that can make it the right choice for certain projects. Its simpler syntax, integrated language, type safety, improved modularity, and integration with other Azure tools make it an attractive option for developers who are focused on Azure-specific infrastructure. \n\nTerraform has several advantages over Bicep in terms of multi-cloud support, community, modular design, declarative language, state management, documentation, provider support, configuration options, testing options, and maturity. \n\nChoosing the right IAC tool for your organization is critical, and evaluating the features of each tool can help you make an informed decision. Ultimately, the choice between Terraform and Bicep will depend on the specific needs of your organization and the nature of your projects.",
    "lastmodified": "2023-02-24T10:27:33.487756467Z",
    "tags": null
  },
  "/posts/lang-terraform-quickstart": {
    "title": "Terraform Quick Start",
    "content": "\n\nIn the introduction to [Terraform](posts/lang-terraform) we got a general overview\n\n## Getting Started\n\nNow \n\n```bash\nterraform init\nterraform plan\nterraform apply\nterraform destroy\n```\n\n![WebHook](lang-terraform-quickstart/s.topdesk.webhook.png)\n\nsample notes",
    "lastmodified": "2023-02-24T10:27:33.487756467Z",
    "tags": null
  },
  "/posts/personal-reflection-2018": {
    "title": "Hitting Reset",
    "content": "\n\n10 Years, It is hard to believe that I have been posting thoughts here that long. And how so much has changed since I begun?\n\nI started this journey with the encouragement of some amazing people in Microsoft, as an opportunity to spread the news about *Hyper-V* and even more relevant at the time *System Center Virtual Machine Manager* which was still known by its code name!.\n\u003c!--more--\u003e\nMy daily experience with this application, Windows Server, and real-world enterprise issues; positioned me at one of the leading edges of Microsoft Technologies; and fully armed with a true business driver pushing forward. Wounds and pains exposed, I gained a lot of insight to the digital plumbing of these technologies and as a result of a lot of fantastic information to share - sometimes not good news; but never the less - reality.\n\nI have primarily worked in the mindset that when I find an issue to be addressed, before sharing, escalating or attacking - I need to stop and consider solutions; which normally result in a more constructive and progressive approach to unblocking my path. That ethos spans back to my days working as what would be considered today in 2018 as an *IoT* architect; but 20 years ago in a Rubber Molding plant, The Operations Manager always reminded me as I entered his office, \"If you don't have some suggestion for a solution before entering and presenting a problem, leave now, and come back when I am prepared (But don't spend all day - Problems cost money!).\"\n\nIn Hindsight, this approach challenged my limits every day; but I now also realise that he actually had no technical knowledge, and without my suggestions, we were heading the route of the Titanic!\n\n## System Center\n\nWhile the solution itself continues to live on, as clear from the very recent launch of *System Center 2019* at the Ignite Conference in Florida; My own passion and engagement with this technology has ultimately diminished to a point of history., despite co-authoring and technically reviewing a number of books, speaking at so many events, and investing 1000's of hours.\n\n## Personal Redevelopment\n\nAfter almost 20 years I changed Jobs, A decision which was extremely difficult to make; and honestly post that change point; I took at least 6 more months to adjust to the new world order.\n\nI found myself amidst a team of like-minded peers, left to find a niche which I could own. Despite working with fantastic scenarios, these new challenges were amazing; and I was learning new stuff again. But, yet I still felt uninspired.\n\nJust reflect on the number of blog posts I have published in the last 3 years.\n\nMy personal life also took a major change; and today after celebrating 21 years of marriage; I am a super proud father of two amazing girls, with my oldest just after celebrating her 4 birthday and the youngest just turned 2.\n\nWhen I reflect on these massive changes, it is a totally different world from when I stood just 10 years ago.\n\n## Inspiration\n\nLast week I participated in my first **Microsoft Ignite** event; and spent the vast majority of this opportunity meeting with so many old friends who have also evolved into completely new roles within their organizations.\n\nAs an example, Mr Taylor Brown; I had the honour of meeting Taylor for the first time almost 12 years ago. Back then we both were working on Test Scenarios for Hyper-V; in his role, he ran the labs for Microsoft's internal testing; and I was responsible for our internal *Technology Adoption Program (TAP)* Pilot testing. Today, Taylor owns the *Docker (Container)* features in Windows Server. An amazing achievement, from an inspiring person and a good friend. \n\nThere are so many amazing people, with just as amazing stories; and I was so proud to be able to stop, and say hello to these *icons*, and learn how their lives have also changed.\n\n## Governance\n\nAs the adoption, and practices of Cloud become centrally focused for so many organizations the focus shifts left, as Compliance, Control, and Culture changes ignite to enable a completely fresh view of the potential.\n\nWhen I combine past experience, with the foundational tooling which 3rd parties like Terraform offer, and native tooling which Microsoft adding to the core of their offerings, the next challenge is clear.\n\nNow, I see a clear path to assist organizations of any size to evolve from what might have been the chaos of Shadow IT, the central control of IT, or the old practices of Enterprise Architects; and guide them to a culture driven enablement of Cloud; supported with *Governance* and enabling that missing **trust** thought the use of *Safety Guard Rails*\n\n## Finding my Mojo\n\nLooking back at Ignite and the last 12 months of work; I now feel like I have a new rhythm. I have found a new passion - Namely that of enabling organizations on this transformation trough common sense, debate and technology.\n\nAddressing political issues, and provisioning the structures of support required to encourage trust and co-operation, all of which is based on logical technical foundations *(Yes Mr Spock!)*. \n\nEven more rewarding, I am actually observing directly the impact this has on people and processes as they evolve their life's with the culture changes required to start a new fabric of growth in cloud and DevOps practices; while also addressing their relationships with the business owners.\n\nI believe I have found my *Mojo*.\n\n## The Next Step...\n\nOver the last years, I have had the honour of presenting at so many fantastic conferences, delivering workshops, and engagement in meetups. When I reflect on the topics I have focused on these all have contributed to building strong foundational elements to this new way. \n\nTopics ranging from Containerization and Automation with Docker and Kubernetes, Serverless to AI, BOT Frameworks to Python, Git flow to Infrastructure as Code, DevOps to Event Handling; while all feel very disjointed, these technologies combined are core to understanding how the world is evolving, and therefore how the organizations can adopt.\n\nIts time to **Hit Refresh**, and join me on this next wave, as I share, present, document, and offer guidance; both here on the Blog, On stages in various locations and professionally, through a range of mediums from 'hands-on' demonstrations, Technical guides, papers, and talks.\n\nI have my *mojo* charged and ready; Have You?",
    "lastmodified": "2023-02-24T10:27:33.487756467Z",
    "tags": null
  },
  "/posts/sw-ssg-jekyll_with_azure_devops": {
    "title": "Constructing a new Home with Jekyll and Azure DevOps",
    "content": "\n\nOne of the unspoken truths behind the lack of posts on ths [blog](blog) in recent history was due to a few bugs, which in the end resulted in an experience where from home it appeared that any new content was published and working; but outside this fortress in the real world, there was a large silence echoing.\n\nI really only discovered this issue in May of this year (2018), and was, to say the least, a little agitated with the situation and decided then to change the approach to how I save my notes and share my thoughts.\n\n## [Jekyll](Jekyll)\n\nAfter a lot of hours hacking at CSS and JS, neither of which are my strongest points; combined with a whole lot of *liquid* scripting, which is based on the [Python](Python) Jinja library; I chose to leverage the open source Jekyll project.\n\nThis is not to say, that I might not reconsider this again as I am pretty intrigued also with [Hugo](Hugo); but one point is for sure... My days struggling with *Wordpress* are history. \n\nDon't get me wrong, Wordpress is great, even fantastic, but when it breaks, or its hacked (and boy have I been hacked), or when the comments system becomes a spam target; then its a total nightmare to have to deal with.\n\nI want something that is easy to use, a lot less prone to hacking, and painless to host; so my choice was clear from the start - I was going to use a Static Site Generator\n\n## Building\n\nLeveraging [GIT](GIT) for my version control, I have a simple pipeline which rebuilds a new version of the site each time a new commit is made to the repository. I do like to tweak and have actually no less than two approaches to the effort\n\n```mermaid\ngraph LR\n    A(Blog Repository)\n    B(Build Pipeline)\n    C(Docker Based Build)\n    D(Native Build)\n    E(Publish Built Site)\n\n    A -.-\u003e|Git Push Trigger| B\n    B --\u003e C\n    B --\u003e D\n    C --\u003e E\n    D --\u003e E\n```\n\nAs I spend the majority of my time focused on Microsoft Technology stack, I am leveraging [Azure DevOps](Azure DevOps) to run my build process; however, if you prefer other tools, for example, Jenkins, CircleCI, etc; then the concepts should be easily transportable, as there is nothing truly complex happening at this point.\n\n### Docker Build Pipeline\n\nThis version of the pipeline is my favourite, as I can use the same commands on my workstation to run a local web server to watch in realtime what my edits are going to look like when I finally commit, with 100% confidence that there will be no drift, as I use the exact same container for both roles, development and deployment\n\nThe pipeline I am sharing is in YAML format, which we are going to see a whole lot most of over time, and by sharing this you can easily recreate your own build pipeline with nothing more than a good paste!\n\nThe build is running on a hosted Ubuntu 16.04 instance, but this could be easily replaced with a dedicated build node; however for the amount of time I will use for the building, I should fall well inside the free monthly allocation offered in Azure DevOps; so, for now, this is perfect.\n\nThe pipeline has only 3 steps\n\n```mermaid\ngraph TD\n    A[Retrieve the relevant commit from Git Repo]\n    B(Run Docker Image to Build Site)\n    C(Move Generated HTML Site to Staging Area)\n    D(Publish Built Site)\n\n    A -.-\u003e B\n    B --\u003e C\n    C --\u003e D\n```\n\nThe *YAML* representation of the flow is as follows; you can also choose to add the steps in the UX and provide the data below into the relevant fields, as there is a 1:1 relationship between the UX and the YAML Infrastructure as Code\n\n```yaml\nresources:\n- repo: self\nqueue:\n  name: Hosted Ubuntu 1604\nsteps:\n- task: Docker@1\n  displayName: 'Run an image'\n  inputs:\n    containerregistrytype: 'Container Registry'\n\n    command: 'Run an image'\n\n    imageName: 'jekyll/builder:latest'\n\n    qualifyImageName: false\n\n    volumes: |\n     $(Build.SourcesDirectory):/srv/jekyll\n     $(Build.BinariesDirectory):/srv/jekyll/_site\n     \n\n    workingDirectory: '$(Build.SourcesDirectory):/srv/jekyll'\n\n    containerCommand: 'jekyll build --future'\n\n    runInBackground: false\n\n- task: CopyFiles@2\n  displayName: 'Copy Files to: $(Build.ArtifactStagingDirectory)'\n  inputs:\n    SourceFolder: '$(Build.BinariesDirectory)'\n\n    TargetFolder: '$(Build.ArtifactStagingDirectory)'\n\n\n- task: PublishBuildArtifacts@1\n  displayName: 'Publish Artifact: _site'\n  inputs:\n    ArtifactName: '_site'\n```\n\n### Native Build Pipeline\n\nThe Native approach does not offer a whole lot of immediate advantages over the docker version of the pipeline; I honestly created this to prove to myself that I could. \n\nHowever, after creating this, I do see an advantage. If I should choose to create a dedicated Build Server; I would be able to have the *Ruby bundler* and all the *Jekyll gems* pre-staged on the node; which would remove almost 3 minutes from the build pipeline, as these steps would not need to be repeated every time I executed a new build.\n\nNow, I would have expected the Docker approach to have this as an advantage with the Gems pre-installed in the container, but that's not the case with the official container I have used in the other pipeline; As a result, both pipelines take 3.5 minutes to prepare, build and publish my site artefacts currently.  Clearly, I have a lot of room to make this better.\n\nThis pipeline is a little more verbose with 5 steps currently\n\n\nThe pipeline has only 3 steps\n\n```mermaid\ngraph TD\n    A[Retrieve the relevant commit from Git Repo]\n    B(Use a Current Release of Ruby)\n    C(Install the Ruby Bundler toolchain)\n    D(Use Bundler to install the Jekyll dependencies)\n    E(Build the Jekyll site to the Staging Area)\n    F[Publish Built Site]\n\n    A -.-\u003e B\n    B --\u003e C\n    C --\u003e D\n    D --\u003e E\n    E --\u003e F\n```\n\nThe *YAML* representation of the flow is very similar to the previous sample, this time however you are going to really just been looking at some shell commands, which run essentially on any platform we can host ruby on.\n\n\n```yaml\nresources:\n- repo: self\nqueue:\n  name: Hosted Ubuntu 1604\nsteps:\n\n- task: UseRubyVersion@0\n  displayName: 'Use Ruby \u003e= 2.4'\n\n\n- script: 'gem install bundler' \n  displayName: 'Install bundler'\n\n- script: 'bundle install' \n  displayName: 'Install Jekyll and Dependencies'\n\n- script: 'bundle exec jekyll build -d $(Build.ArtifactStagingDirectory)' \n  displayName: 'Build Jekyll Static Site'\n\n- task: PublishBuildArtifacts@1\n  displayName: 'Publish Artifact: _site'\n  inputs:\n    ArtifactName: '_site'\n```\n\n## Next Steps\n\nWith a built site, published; what we really have is a *.ZIP* file which contains all the generated HTML which we can drop onto our web server to publish to the world. \n\nThere are many choices on the web hosting platform to use, keep tuned, and I will share with you the solution I have elected to use for this site",
    "lastmodified": "2023-02-24T10:27:33.487756467Z",
    "tags": null
  }
}